// example.pal - Comprehensive language feature showcase

// ============================================================================
// IMPORTS
// ============================================================================
import std/io;
import std/collections;
import ./utils/math;
import ../common/helpers;

// ============================================================================
// ENUMS (Simple and with Data)
// ============================================================================
enum Color {
    Red,
    Green,
    Blue,
    Custom = 255
}

enum Shape {
    Circle(radius: f32),
    Rectangle(width: f32, height: f32),
    Triangle(a: f32, b: f32, c: f32)
}

enum Option {
    Some(value: int),
    None
}

// ============================================================================
// STRUCTS (Data-only)
// ============================================================================
struct Point {
    x: f32;
    y: f32;
    z: f32;
}

struct Vector2D {
    x: i32;
    y: i32;
}

struct Person {
    name: string;
    age: u8;
    height: f32;
}

// ============================================================================
// CLASSES (Data + Methods)
// ============================================================================
class ArrayList {
    private:
        data: int*;
        size: u64;
        capacity: u64;

    public:
        // Constructor
        ArrayList(initial_capacity: u64) {
            capacity = initial_capacity;
            size = 0;
            data = new int[capacity];
        }

        // Destructor
        ~ArrayList() {
            delete data;
        }

        // Methods
        push(value: int): void {
            if (size >= capacity) {
                resize(capacity * 2);
            }
            data[size] = value;
            size++;
        }

        get(index: u64): int {
            return data[index];
        }

        length(): u64 {
            return size;
        }

    private:
        resize(new_capacity: u64): void {
            new_data: int* = new int[new_capacity];
            i: u64 = 0;
            while (i < size) {
                new_data[i] = data[i];
                i++;
            }
            delete data;
            data = new_data;
            capacity = new_capacity;
        }
}

class Calculator {
    public:
        Calculator() {}
        ~Calculator() {}

        add(a: i32, b: i32): i32 {
            return a + b;
        }

        multiply(a: f64, b: f64): f64 {
            return a * b;
        }
}

// ============================================================================
// GLOBAL VARIABLES
// ============================================================================
const PI: f64 = 3.14159265359;
const MAX_BUFFER_SIZE: u32 = 1024;
global_counter: i32 = 0;

// ============================================================================
// FUNCTIONS
// ============================================================================

// Basic function with return type
square(x: i32): i32 {
    return x * x;
}

// Function with no return (void is implicit)
print_message(msg: string) {
    // String interpolation
    output: string = "Message: ${msg}";
    // Function call would go here
}

// Variadic function
sum(first: i32, ...): i32 {
    result: i32 = first;
    // In real implementation, would iterate over varargs
    return result;
}

// Function demonstrating all operators
demonstrate_operators(a: i32, b: i32): void {
    // Arithmetic operators
    add: i32 = a + b;
    sub: i32 = a - b;
    mul: i32 = a * b;
    div: i32 = a / b;
    mod: i32 = a % b;

    // Comparison operators
    eq: bool = a == b;
    ne: bool = a != b;
    lt: bool = a < b;
    le: bool = a <= b;
    gt: bool = a > b;
    ge: bool = a >= b;

    // Logical operators
    and_result: bool = eq && ne;
    or_result: bool = eq || ne;
    not_result: bool = !eq;

    // Bitwise operators
    bit_and: i32 = a & b;
    bit_or: i32 = a | b;
    bit_xor: i32 = a ^ b;
    bit_not: i32 = ~a;
    left_shift: i32 = a << 2;
    right_shift: i32 = a >> 1;

    // Assignment operators
    x: i32 = 10;
    x += 5;   // x = 15
    x -= 3;   // x = 12
    x *= 2;   // x = 24
    x /= 4;   // x = 6
    x %= 4;   // x = 2
    x &= 3;   // x = 2
    x |= 1;   // x = 3
    x ^= 2;   // x = 1
    x <<= 2;  // x = 4
    x >>= 1;  // x = 2

    // Increment/decrement
    y: i32 = 5;
    y++;      // postfix increment
    ++y;      // prefix increment
    y--;      // postfix decrement
    --y;      // prefix decrement

    // Ternary operator
    max: i32 = (a > b) ? a : b;
}

// Function demonstrating control flow
control_flow_demo(n: i32): void {
    // If-else statement
    if (n > 0) {
        result: string = "positive";
    } else if (n < 0) {
        result: string = "negative";
    } else {
        result: string = "zero";
    }

    // While loop
    counter: i32 = 0;
    while (counter < n) {
        counter++;
        if (counter == 5) {
            continue;
        }
        if (counter > 10) {
            break;
        }
    }

    // For loop
    for (i: i32 = 0; i < n; i++) {
        sum: i32 = sum + i;
    }

    // For loop variations
    for (; counter < 20; counter++) {
        // loop body
    }

    for (;;) {
        // infinite loop
        break;
    }
}

// Function demonstrating pattern matching
pattern_matching_demo(shape: Shape): f32 {
    area: f32 = 0.0;

    // Pattern matching with enum variants
    match (shape) {
        Shape::Circle(r) => {
            area = PI * r * r;
        }
        Shape::Rectangle(w, h) => {
            area = w * h;
        }
        Shape::Triangle(a, b, c) => {
            // Heron's formula
            s: f32 = (a + b + c) / 2.0;
            area = (s * (s - a) * (s - b) * (s - c)) ^ 0.5;
        }
    }

    return area;
}

// More pattern matching examples
advanced_pattern_matching(opt: Option, color: Color, point: Point): void {
    // Match with guard
    match (opt) {
        Option::Some(x) if x > 0 => {
            msg: string = "Positive: ${x}";
        }
        Option::Some(x) if x < 0 => {
            msg: string = "Negative: ${x}";
        }
        Option::Some(_) => {
            msg: string = "Zero";
        }
        Option::None => {
            msg: string = "No value";
        }
    }

    // Match with or-patterns
    match (color) {
        Color::Red | Color::Green | Color::Blue => {
            msg: string = "Primary color";
        }
        _ => {
            msg: string = "Custom color";
        }
    }

    // Match with struct pattern
    match (point) {
        Point { x: 0.0, y: 0.0, z: 0.0 } => {
            msg: string = "Origin";
        }
        Point { x, y, z: 0.0 } => {
            msg: string = "On XY plane at (${x}, ${y})";
        }
        Point { x, y, z } => {
            msg: string = "3D point at (${x}, ${y}, ${z})";
        }
    }

    // Match with type patterns
    value: i32 = 42;
    match (value) {
        x: i32 if x > 100 => {
            msg: string = "Large number";
        }
        x: i32 if x > 0 => {
            msg: string = "Small positive";
        }
        _ => {
            msg: string = "Zero or negative";
        }
    }
}

// Function demonstrating pointers and arrays
pointers_and_arrays_demo(): void {
    // Arrays
    numbers: i32[5];
    numbers[0] = 1;
    numbers[1] = 2;
    numbers[2] = 3;
    numbers[3] = 4;
    numbers[4] = 5;

    // Dynamic arrays
    dynamic: i32* = new i32[10];
    dynamic[0] = 100;
    delete dynamic;

    // Pointers
    x: i32 = 42;
    ptr: i32* = &x;         // Address-of operator
    value: i32 = *ptr;      // Dereference operator
    *ptr = 100;             // Modify through pointer

    // Pointer arithmetic (implicit in array access)
    first: i32 = numbers[0];
    second: i32 = numbers[1];

    // Multi-dimensional arrays
    matrix: i32[3][3];
    matrix[0][0] = 1;
    matrix[1][1] = 5;
    matrix[2][2] = 9;

    // Pointer to pointer
    pptr: i32** = &ptr;
}

// Function demonstrating type casting
type_casting_demo(): void {
    // Explicit casts
    i: i32 = 42;
    f: f32 = (f32)i;
    d: f64 = (f64)f;
    b: i8 = (i8)i;

    // Pointer casts
    ptr: void* = &i;
    int_ptr: i32* = (i32*)ptr;

    // Array to pointer
    arr: i32[10];
    arr_ptr: i32* = (i32*)arr;
}

// Function demonstrating string interpolation
string_interpolation_demo(): void {
    name: string = "Alice";
    age: i32 = 25;
    height: f32 = 1.65;

    // String interpolation with variables
    greeting: string = "Hello, ${name}!";
    info: string = "${name} is ${age} years old and ${height}m tall.";

    // String interpolation with expressions
    next_year: string = "Next year, ${name} will be ${age + 1} years old.";
    calculation: string = "2 + 2 = ${2 + 2}";

    // Complex expressions in interpolation
    double_age: i32 = age * 2;
    complex: string = "Double age: ${double_age}, half age: ${age / 2}";
}

// Function using all sized integer types
sized_types_demo(): void {
    // Signed integers
    a: i8 = 127;
    b: i16 = 32767;
    c: i32 = 2147483647;
    d: i64 = 9223372036854775807;

    // Unsigned integers
    ua: u8 = 255;
    ub: u16 = 65535;
    uc: u32 = 4294967295;
    ud: u64 = 18446744073709551615;

    // Floating point (if supported)
    f1: f32 = 3.14159;
    f2: f64 = 2.718281828459045;
}

// ============================================================================
// MAIN FUNCTION
// ============================================================================
main(): i32 {
    // Create objects
    calc: Calculator = Calculator();
    list: ArrayList = ArrayList(10);

    // Use calculator
    sum: i32 = calc.add(5, 3);
    product: f64 = calc.multiply(2.5, 4.0);

    // Use array list
    list.push(1);
    list.push(2);
    list.push(3);
    len: u64 = list.length();

    // Create structs
    origin: Point = Point { x: 0.0, y: 0.0, z: 0.0 };
    p1: Point = Point { x: 1.0, y: 2.0, z: 3.0 };
    person: Person = Person { name: "Bob", age: 30, height: 1.75 };

    // Create enums
    red: Color = Color::Red;
    circle: Shape = Shape::Circle(5.0);
    rect: Shape = Shape::Rectangle(4.0, 6.0);

    // Calculate areas using pattern matching
    circle_area: f32 = pattern_matching_demo(circle);
    rect_area: f32 = pattern_matching_demo(rect);

    // Demonstrate control flow
    control_flow_demo(10);

    // Demonstrate operators
    demonstrate_operators(15, 7);

    // Demonstrate pointers and arrays
    pointers_and_arrays_demo();

    // String interpolation
    message: string = "Program completed successfully!";
    final: string = "Result: ${message}";

    // Const variables
    const RESULT: i32 = 42;
    const MESSAGE: string = "The answer is ${RESULT}";

    // Call variadic function
    total: i32 = sum(1, 2, 3, 4, 5);

    // Member access with arrow operator
    point_ptr: Point* = &p1;
    x_value: f32 = point_ptr->x;
    y_value: f32 = point_ptr->y;

    // Dot operator for direct access
    z_value: f32 = p1.z;

    // Cleanup happens automatically via destructors
    return 0;
}
