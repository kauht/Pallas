EBNF Syntax:
    - Nonterminals are written in CamelCase (e.g. Program, Statement).
    - Terminals are token names or literal characters (e.g. TOKEN_IDENT, '(', ')' ).
    - Repetition: { X } means zero or more occurrences of X.
    - Optional: [ X ] means zero or one occurrence of X.
    - Grouping: ( X | Y ) groups alternatives.
    - Sequence: X Y means X followed by Y.

Notes:
    - This file uses token names (e.g. TOKEN_IDENT) to indicate terminals emitted by the lexer.
    - Use [ ... ] for optional pieces and { ... } for repetition to follow EBNF conventions.
    - Constructors are methods with the same name as the class (no return type)
    - Destructors are methods prefixed with '~' and same name as class (no return type)

# Program
Program = { Import } , { TopDecl } ;

TopDecl = FunDecl | StructDecl | ClassDecl | VarDecl ;

Import = ( TOKEN_IMPORT | TOKEN_INCLUDE ) , TOKEN_IDENT , { TOKEN_DOT , TOKEN_IDENT } , TOKEN_SEMICOLON ;

# Types (EBNF)
Type = BuiltinType | UserType | PointerType | TOKEN_VOID ;

BuiltinType = TOKEN_INT
            | TOKEN_FLOAT
            | TOKEN_DOUBLE
            | TOKEN_BOOL
            | TOKEN_CHAR
            | TOKEN_STRING
            | SizedType ;

SizedType = TOKEN_I8 | TOKEN_I16 | TOKEN_I32 | TOKEN_I64
          | TOKEN_U8 | TOKEN_U16 | TOKEN_U32 | TOKEN_U64
          | TOKEN_F8 | TOKEN_F16 | TOKEN_F32 | TOKEN_F64 ;

UserType = TOKEN_IDENT ;

PointerType = Type , { TOKEN_STAR } ;

# Visibility Modifiers (labels that apply to subsequent members)
VisibilityLabel = ( TOKEN_PUBLIC | TOKEN_PRIVATE ) , TOKEN_COLON ;

# Declarations
FunDecl = TOKEN_IDENT , TOKEN_LPAREN , [ ParamList ] , TOKEN_RPAREN , TOKEN_COLON , Type , Block ;

ParamList = Param , { TOKEN_COMMA , Param } , [ TOKEN_COMMA , TOKEN_ELLIPSIS ] ;

Param = TOKEN_IDENT , TOKEN_COLON , Type ;

VarDecl = [ TOKEN_CONST ] , TOKEN_IDENT , TOKEN_COLON , Type , [ TOKEN_ASSIGN , Expression ] , TOKEN_SEMICOLON ;

StructDecl = TOKEN_STRUCT , TOKEN_IDENT , TOKEN_LBRACE , { StructMember } , TOKEN_RBRACE , [ TOKEN_SEMICOLON ] ;

StructMember = VarDecl | FunDecl ;

ClassDecl = TOKEN_CLASS , TOKEN_IDENT , TOKEN_LBRACE , { ClassMember } , TOKEN_RBRACE , [ TOKEN_SEMICOLON ] ;

ClassMember = VisibilityLabel | VarDecl | MethodDecl | ConstructorDecl | DestructorDecl ;

MethodDecl = TOKEN_IDENT , TOKEN_LPAREN , [ ParamList ] , TOKEN_RPAREN , TOKEN_COLON , Type , Block ;

ConstructorDecl = TOKEN_IDENT , TOKEN_LPAREN , [ ParamList ] , TOKEN_RPAREN , Block ;

DestructorDecl = TOKEN_TILDE , TOKEN_IDENT , TOKEN_LPAREN , TOKEN_RPAREN , Block ;

# Statements
Statement = IfStmt | WhileStmt | ForStmt | ReturnStmt | ExpressionStmt | Block | VarDecl ;

IfStmt = TOKEN_IF , TOKEN_LPAREN , Expression , TOKEN_RPAREN ,
         Block , [ TOKEN_ELSE , ( IfStmt | Block ) ] ;

WhileStmt = TOKEN_WHILE , TOKEN_LPAREN , Expression , TOKEN_RPAREN , Block ;

ForStmt = TOKEN_FOR , TOKEN_LPAREN ,
          ( VarDecl | ExpressionStmt | TOKEN_SEMICOLON ) ,
          [ Expression ] , TOKEN_SEMICOLON , [ Expression ] , TOKEN_RPAREN , Block ;

ReturnStmt = TOKEN_RETURN , [ Expression ] , TOKEN_SEMICOLON ;

BreakStmt = TOKEN_BREAK , TOKEN_SEMICOLON ;

ContinueStmt = TOKEN_CONTINUE , TOKEN_SEMICOLON ;

ExpressionStmt = Expression , TOKEN_SEMICOLON ;

Block = TOKEN_LBRACE , { Statement } , TOKEN_RBRACE ;

# Expressions (precedence expressed via rule hierarchy)
Expression = Assignment ;

Assignment = LogicalOr , [ AssignmentOp , Assignment ] ;

AssignmentOp = TOKEN_ASSIGN
             | TOKEN_PLUS_ASSIGN
             | TOKEN_MINUS_ASSIGN
             | TOKEN_STAR_ASSIGN
             | TOKEN_SLASH_ASSIGN
             | TOKEN_AND_EQUALS
             | TOKEN_OR_EQUALS
             | TOKEN_XOR_EQUALS
             | TOKEN_LSHIFT_EQUALS
             | TOKEN_RSHIFT_EQUALS ;

LogicalOr = LogicalAnd , { TOKEN_LOGICAL_OR , LogicalAnd } ;

LogicalAnd = BitwiseOr , { TOKEN_LOGICAL_AND , BitwiseOr } ;

BitwiseOr = BitwiseXor , { TOKEN_PIPE , BitwiseXor } ;

BitwiseXor = BitwiseAnd , { TOKEN_CARET , BitwiseAnd } ;

BitwiseAnd = Equality , { TOKEN_AMPERSAND , Equality } ;

Equality = Comparison , { ( TOKEN_EQUAL | TOKEN_NOT_EQUAL ) , Comparison } ;

Comparison = Shift , { ( TOKEN_LESS | TOKEN_LESS_EQUAL | TOKEN_GREATER | TOKEN_GREATER_EQUAL ) , Shift } ;

Shift = Additive , { ( TOKEN_LEFT_SHIFT | TOKEN_RIGHT_SHIFT ) , Additive } ;

Additive = Multiplicative , { ( TOKEN_PLUS | TOKEN_MINUS ) , Multiplicative } ;

Multiplicative = Unary , { ( TOKEN_STAR | TOKEN_SLASH | TOKEN_PERCENT ) , Unary } ;

Unary = ( TOKEN_LOGICAL_NOT | TOKEN_MINUS | TOKEN_TILDE | TOKEN_AMPERSAND | TOKEN_STAR ) , Unary
      | Postfix ;

Postfix = Primary , { PostfixOp } ;

PostfixOp = TOKEN_PLUS_PLUS
          | TOKEN_MINUS_MINUS
          | TOKEN_LPAREN , [ ArgumentList ] , TOKEN_RPAREN    // Function call
          | TOKEN_LBRACKET , Expression , TOKEN_RBRACKET      // Array subscript
          | TOKEN_DOT , TOKEN_IDENT                            // Member access
          | TOKEN_ARROW , TOKEN_IDENT ;                        // Pointer member access

ArgumentList = Expression , { TOKEN_COMMA , Expression } ;

Primary = TOKEN_IDENT
        | TOKEN_INT_LITERAL
        | TOKEN_FLOAT_LITERAL
        | TOKEN_CHAR_LITERAL
        | TOKEN_STRING_LITERAL
        | TOKEN_TRUE
        | TOKEN_FALSE
        | TOKEN_NULL
        | TOKEN_LPAREN , Expression , TOKEN_RPAREN
        | NewExpression
        | ConstructorCall ;

NewExpression = TOKEN_NEW , TOKEN_LPAREN , Type , TOKEN_RPAREN ;

ConstructorCall = UserType , TOKEN_LPAREN , [ ArgumentList ] , TOKEN_RPAREN ;

DeleteExpression = TOKEN_DELETE , TOKEN_LPAREN , Expression , TOKEN_RPAREN ;

# Extras / Notes
// Variadic functions: use TOKEN_ELLIPSIS '...' at end of parameter lists.
// Import/Include paths may include multiple dotted identifiers (handled by Import rule).
// Pointer types are represented by trailing '*' tokens.
// Arrays use subscript notation with brackets.
// Classes support public:/private: visibility labels (like C++).
//   Visibility labels apply to all following members until another label.
// Constructors have same name as class, no return type.
// Destructors prefixed with '~', same name as class, no return type.
// Object construction follows Pallas declaration syntax:
//   Stack: name: Type = Type(args);
//   Heap:  ptr: Type* = new(Type);
// Constructor calls (Type(args)) can appear as expressions in initialization.
// Memory management: new(Type) and delete(ptr).
